{/* apps/harbor/main/src/routes/posts/my-css-is-type-safe.mdx */}

# My CSS is Type Safe

import { Author } from '../../components/$author'

<Author name='John Carter' date='2025-06-17'　src='https://randomuser.me/api/portraits/men/75.jpg' />

---

> 本記事の対象読者について
> 
> 本記事は、CSS 設計において秩序と柔軟性の両立を目指す開発者、および TypeScript の型システムを活用した UI 実装に関心を持つ技術者を主な対象としています
> 
> 以下のような前提に立っています：
> 
> - クラス名設計やスタイル構造の属人化に課題意識を持っている
> 
> - Tailwind CSS や BEM など既存のスタイル設計手法を一通り経験している
> 
> - フレームワークやライブラリに依存せず、自前の構造を明示的に制御したい
> 
> - CSS を「装飾」ではなく「構造の一部」として捉える思想に共感する
> 
> そのため、以下のような方には主旨がそぐわない可能性があります：
> 
> - すでに特定の UI フレームワーク（MUI、Chakra UI 等）に満足している方
> 
> - 型システムの恩恵をあまり重視しない、あるいは関心が薄い方
> 
> - とにかく素早く UI を構築できればよく、設計思想には興味がない方
> 
> - 「CSS は非構造でよい」「自由であることが本質」と考える方
> 
> 本稿は、すべての開発現場における「正解」を示すものではありません
> 
> ただし、もしあなたが CSS にまつわる不整合や不安定性に対して理論的な解決を求めているのであれば、この文章はその一助になるかもしれません
> 
> あくまでこれは一つの具体解であり、普遍解を装うものではありません

---

## CSS 混乱の時代

---

かつてスタイルを書くという行為は、純粋に見た目を整えることに集中さえすればよかったものでした

`color` や `margin` を書けばその通りにブラウザが描画してくれる、明示的かつ単純、そして直感的です

しかし 2025 年現在の CSS (スタイリング) を取り巻く選択肢は複雑を極めています。主要な選択肢すら俯瞰できる人は限られてくるかもしれません

実際何をもって CSS を「書く」とするのか、その定義すら人によって異なります

ある人はユーティリティクラスを並べることを指し、ある人は UI フレームワークの部品を組み合わせることを指し、ある人は JS ファイル内で `css({})` と書くことを意味します

ここまで多様で複雑になった理由の一端は明白で、Web UI はいまや単なる「装飾」ではなく、製品価値そのものになったからです

プロダクトの印象や体験は UI に強く依存するようになり、その品質を安定的に保つため、さまざまな設計手法やツールが登場します

一方で、それらの多くは CSS という言語そのものが抱える構造的な課題に対処しようとするものでもありました

---

### CSS 内在的設計課題

---

つまり CSS を「何も考えずに書く」と以下の課題に高確率で対峙することになります。それは CSS に限った話ではありませんが、あくまでレイヤー的に現れやすいということです

| 課題 | 内容 | 影響 |
| -- | -- | -- |
| スコープ汚染 | グローバルなクラス名が競合・衝突しやすく、意図せぬスタイル崩れが発生 | チーム開発や大規模化で破綻しやすい |
| 再利用困難 | スタイルが文脈依存・構造依存になりやすく、部品としての再利用が難しい | コンポーネント化や保守性を阻害 |
| 命名のつらさ | クラス名の粒度・ルール・統一感のなさが設計の属人化を招く | 規模拡大で混乱を生む |
| 動的スタイル対応 | 状態に応じてスタイルを切り替える仕組みが CSS 単体では困難 | ロジックとの乖離、JS との橋渡しが必要に |
| 型がない | スタイル定義に補完・検証・一貫性の仕組みが存在しない | バグ発見やリファクタ時のコストが高い |
| デザインと実装の乖離 | Figma 等の UI 設計と実際のコードが乖離しやすい | デザイナーとエンジニアの連携を阻害 |

CSS は`color: red`と書けば、文字が赤くなるといったシンプルな振る舞いに最適化された言語です

これは直感的な一方で、責務の分離やスコープ制御、状態ごとのスタイル切り替えといった、UI 開発における複雑な要件を担うには設計上の限界もありました

> ただしそんな CSS も時代とともに進化していきます。たとえばコンテナクエリに加え、最近では`if()`関数も導入されました （Chrome 137 2025-05-27 より）:
> ```css
> div {
>   background-color: if(
>     style(--theme: dark): black;
>     else: white
>   );
> }
> ```

---

### CSS 秩序化の系譜

---

現在プロダクトの UI/UX はブランドと直結し、競争力そのものになっています。その原資である DX (Developer Experience) も非常に重要であることも明らかです

私達は UI が綺麗だからそのサービスを使うわけではありませんが、理路整然とされたデザインは利用者の認知負荷をさげ、体験を良くすることに一役買います

そしてその品質を継続的に保ち、チームで安全に保守・拡張するために、さまざまなスタイル設計手法やツールが提案されました

以下はそれらの代表的な分類と背景思想をまとめた一例です

| カテゴリ | 目的 | 代表例 |
| -- | -- | -- |
| UI キット系 | UI コンポーネントを一式提供し、デザイン統一と開発速度を両立 | MUI, Chakra UI, Vuetify, Bootstrap |
| 設計指針系（命名・構造） | 意味ある命名や構造で CSS 設計の秩序と責務を明確化 | BEM, ITCSS, Atomic CSS |
| ユーティリティ CSS 系 | 原子的なクラスを HTML に直接記述し、スタイル構築を簡素化 | Tailwind CSS, UnoCSS |
| CSS-in-JS／スコープ設計 | スタイルを JS/TS 内に定義し、コンポーネントにスコープ閉じ込め | Emotion, styled-components |
| 型安全・DSL 志向 | 型補完やトークン管理を通じて一貫性と保守性を高める | vanilla-extract, PandaCSS, Typewind |
| 構文／互換性補助系 | CSS 構文やビルド・互換性を補助。スタイル自体は変えない | PostCSS, SCSS, CSS Modules |

| カテゴリ | 背景・思想的な文脈 |
| - | - |
| UI キット系 | 大規模開発におけるデザインの一貫性と、非デザイナー／非 CSS エンジニアの巻き込みを重視。Figma 連携やチームスケーラビリティを支える |
| 設計指針系（命名・構造） | スタイルがスパゲッティ化しやすい問題に対し、「構造・責務・命名」による秩序ある設計を導入しようとした初期の理論派アプローチ |
| ユーティリティ CSS 系 | クラスを最小単位に分解することで、再利用性・メンテナンス性・学習コストを下げようとした実用主義。デザインと実装の同時進行にも対応 |
| CSS-in-JS／スコープ設計 | コンポーネント単位で状態やロジックとともにスタイルを閉じ込めることで、スコープの衝突やグローバルな依存性を排除し、保守性を担保 |
| 型安全・DSL 志向 | スタイルの定義すら型安全に扱うことで、開発者体験と一貫性を極限まで高めたいという、型指向コミュニティの文脈から派生 |
| 構文／互換性補助系 | もともと CSS 自体の限界（変数・演算・ネストなど）を補う目的で生まれ、のちにビルドツールやモジュール思想と結びついて拡張された |

---

### 分岐した設計思想の行方

---

CSS の課題に対処しようとするたびに、新たな不満や摩擦が生まれます

他の多くの技術領域では、ある程度「共通の理想像」や「合意されたベストプラクティス」が存在します。言語設計やライブラリ内部に閉じた文脈であれば、目的が共有されているため、自然と正解が収束していくからです

しかし CSS の場合、そもそも 「解決したい課題の種類」そのものが人によって異なるという構造的な難しさがあります

- UI コンポーネントの再利用性を高めたい人

- 命名の負担を減らしたい人

- デザインの一貫性とブランド表現を保ちたい人

- 単に素早く画面を組みたい人

これらのすべてが同じ土俵、つまり CSS の文法と仕様という一つの基盤上でぶつかり合っているため、最終的に「これが正解だ」とは言えない状況が続きます

> Tailwind CSS のように現在もっとも合意が形成されつつあるアプローチも存在します
> 
> ただしそれですら全ユースケースにおいて満場一致の「解」とは言い切れないのが CSS にまつわる設計思想の難しさでもあります

さらに CSS は「見た目」に直結するため、デザイナーやフロントエンドエンジニアだけでなく、非エンジニアの関係者も意見を述べやすいという特性があります

これはプロダクトにとっては良いことでもありますが、技術的な設計判断の一貫性を保つという観点では、合意形成を難しくする要因にもなります

たとえ GitHub で数万スターを集めたとしても、「とりあえず今は Next.js か Nuxt を使えば間違いない」といったような収束した常識が CSS まわりではなかなか生まれません

それは CSS が本質的に「何を解決したいのか」が人によって異なる、という土台の不一致があるからです

> 私は CSS の表現力そのものには、確かな自信を持っています
> 
> 著名な Web サービスの UI を模写することも日常的に行っており、CSS の表現としての限界に不満を感じることはほぼありません
> 
> たとえそれが Figma で作られた洗練されたデザインであれ、PDF で共有されたラフな資料であれ、構造と意図を汲み取り、必要なスタイルを組み上げる力には自負があります
> 
> しかし、それを「このフレームワークの流儀に沿って実装してください」と言われた途端、手が止まり、生産性が著しく落ちる、そんな経験も少なくありません
> 
> なぜなら、他者が用意した制約や抽象に従うことが、「表現」ではなく「消化」に近づいてしまうからです
> 
> たとえば以下のようなプロダクトを実装する場面で、あなたなら既存の設計指針やプリセットに自分の表現をねじ込むでしょうか？
> 
> - デザインと機能が密接に結びついたアーティスティックなランディングページ
> 
> - ペライチで構成されたが情報設計と階層構造が非常に繊細なマーケティングサイト
> 
> - UI コンポーネントよりも「体験の流れ」が重視される特殊な業務ツール
>
> きっとそれらを開発している方に、私達が好きな「フレームワーク」や「ライブラリ」をいくら喧伝したところで刺さりません

| カテゴリ | 課題 |
| -- | -- |
| UI キット系 | デザイン／UX の自由度が制限されカスタマイズ性に乏しい。独自性あるブランド表現が難しい場合も |
| 設計指針系（命名・構造） | 運用ルールが複雑化しやすく学習コストや属人化を招く。形式だけが残りがち |
| ユーティリティ CSS 系 | HTML がクラス名だらけで可読性が低下。複雑なデザインには冗長になりやすい。`@apply`を使えば設計指針系課題へと戻る |
| CSS-in-JS／スコープ設計 | 実行時パフォーマンスやビルドサイズへの影響が無視できない。SSR や外部スタイル統合も難所に |
| 型安全・DSL 志向 | 抽象化が進みすぎると非エンジニアや CSS 初心者には理解しづらくなる。導入障壁が高め |
| 構文／互換性補助系 | ビルド依存が強まり構成や環境の複雑化を招く。長期運用時のアップグレードも負担に |

> 2025 年現在も一定の認知・採用実績がある、あるいは後継思想に影響を与えた代表的な手法・技術を取り上げています
> 
> 歴史的に重要だが現代では単独採用されないようなものも、一部はその影響を汲んだ文脈で紹介しています
> 
> 各技術やライブラリはひとつのカテゴリに厳密に収まるとは限りませんし、フレームワークの中に内包されていて、意識すらされないものもあります（Vue 構文の `<style scoped>`など）
> 
> デザインシステム構築を目的とするものが DSL やユーティリティ指向を併せ持つこともあり、本表はあくまで主な思想・傾向に基づいた分類です

> なお「このライブラリにおけるこの課題はこうすれば解決できる」といった具体的な処方箋はすでに多数存在しています
> 
> 本稿の主眼は、どの技術も全ユースケースをカバーする万能解ではないという点にあります
> 
> 特定のニーズや文脈においては最適に見える解法も、それを適用するプロジェクト・組織・人材の状況によっては、逆に課題を増幅させることもあるとご理解ください
> 
> 技術的な評価軸が一致しないまま語られることの多い領域だからこそ、「AはBより優れている」といった単純な比較は、多くの場合で前提のすり替えを含むものです

---

## そして私が何を選んだか

---

ここまで CSS にまつわる設計思想の系譜と、それぞれの背景・利点・課題を見てきました

長くなってしまいましたが、この前提を提示せず「私はこれを使います」と言うのは無責任だと感じたからです

CSS という技術領域は誰もが触れられるがゆえに、選択の重みが軽視されがちです

しかし実際のプロダクト開発では、その選択ひとつでチームの速度も品質も大きく変わります

そして私はその選択として TSS（Type-Safe Style）というスタイル設計の道を選びました

それは万能でも革新的でもありません、今のところ OSS ですらありませんし、前述の課題も多く内包されています

ただ、型の力で「秩序と柔軟性の両立」を目指す、ひとつの静かな提案です

---

### TSS とは: 型で CSS を制御する構文レイヤー

---

TSS は、TypeScript を活用した 型安全な CSS 記述手法です

見た目のために書かれるスタイル定義に対し「明示的な構造」と「静的な補完・検証」を与えることで、設計の秩序と保守性を高めることを目的としています

TSS は DSL（ドメイン固有言語）であることを意図していません

むしろその逆で、CSS の構造性を壊さず、TypeScript の型システムに乗せられる最小限の構文再設計に徹しています

たとえば以下のような特徴を備えています

- `d: 'grid'`, `ai: 'center'`のような省略記法を型補完つきで安全に利用可能

- `s.object()` / `s.style()` による構造と責務の分離

- `hover`, `@media`, `& > *` のようなセレクタや状態表現も構造的に扱える

- セレクタとスタイルが混在せず、常に型付きオブジェクトで管理される

その本質は「CSS-in-JS でも、ユーティリティクラスでも、PostCSS でもない」第 4 の選択肢、TypeScript と相互補完しながら CSS の構造的記述を支援する文法レイヤーです

以下に TSS を使った典型的なスタイル・コンポーネント構成例を示します

この構造の特徴は「責務ごとの分離」「型安全な補完」「状態・セレクタ対応」が 1 ファイルで完結している点です

import { Card } from '../../components/playground/$card.tsx'
import Code from '../../components/playground/$card.tsx?raw'

<Card />

<pre><code class='language-tsx'>{Code}</code></pre>

この構造は

- 構築層: `Card` `Object.assign()`の第一引数、UI 全体の表示構造を構築する

- モデル層: `Card` `Object.assign()`の第二引数、構造的 UI モデルを定義し、責務ごとに部品を分離する

- スタイル定義層: `const card = s.define(...)`によって具体的なスタイル（見た目）を型安全に記述する

の 3 層で構成されています

この分離は Vue の SFC や Svelte における`<template>`、`<script>`、`<style>`のような役割構造を TypeScript の関数型スタイルで再構成したものといえます

> ただし TSS ではこの分離がフレームワーク依存の構文やビルド過程に委ねられていません

- トランスパイラも

- プリプロセッサも

- カスタムディレクティブも

- VSCode プラグインも Vite プラグインも

必要ありません

すべてはプレーンな TypeScript 上で定義され、型安全・補完・責務分離が IDE の標準機能だけで完結します

これは冗長でしょうか？ それとも明示的でしょうか？ または理解不能？ それは受け取る人の感覚・思想に最終的には委ねられるべきことですが、私にとっては見えない構造をフレームワークに預けるのではなく、型とコードの中で明示的に構築していくことが TSS の本質であり、思想です

それは「魔法を使わない」という選択であり、「自分たちで理解し、自分たちで制御できる」構造を築くという選択です

---

### TSS　が目指すもの：　秩序と柔軟性の両立

---

TSS が目指すのは型の力を活用してスタイル定義に「構造的秩序」をもたらしつつ、柔軟な設計と実装の自由度を損なわないという、いわば二律背反のような命題です

既存の CSS 設計手法は多くの場合、この二つのどちらかに寄ることを選びました

秩序に寄った設計は、ルールや制約によって一貫性を保ちます（BEM、Design System、Tailwind CSS の設計指針）

柔軟性に寄った設計は、自由度とスピードを優先します（Vanilla CSS、CSS-in-JS、ユーティリティ未使用）

TSS はそのいずれにも属しません

むしろ「秩序と柔軟性のあいだにある、薄くて鋭いライン」を、TypeScript の型システムと構造的な API 設計によって正面から歩こうとする設計思想です

この思想は、以下のような小さな選択に現れています：

- クラス名を文字列で書く代わりに、型定義されたキーで管理する

- セレクタもプロパティも、文字列ではなく型安全なオブジェクトとして扱う

- hover や @media のような状態や条件も、構文の中にロジックとして組み込める

- スタイルの再利用や合成も、関数ではなく構造体として表現する

TSS において構造とは「決めつけること」ではなく「整理されていること」です

柔軟性とは「どこでも何でも書ける」ことではなく、「安全にカスタマイズできる余白がある」という意味です

このふたつの調和は、たとえば以下のような開発体験を可能にします：

- あるスタイルの継承元を IDE 上で即座に特定できる

- 意図しないマージや重複を型エラーとして検出できる

- 状態の変化に応じたスタイル切り替えが className の動的組み立てよりも自然に記述できる

- コンポーネント設計とスタイル設計が一つのファイル内で論理的に共存できる

- もし必要になったら`s.screen`でも`s.fluid`でもその時はじめて関数として足せばいい

もしあなたが「スタイルの再利用性が低い」「命名がつらい」「設計ルールが属人的」といった CSS 特有の苦しみに共感したことがあるなら、TSS はその痛みをコード構造と型システムのレイヤーで解消する、ひとつの提案になり得るかもしれません

これは現状 OSS プロダクトとして昇華していませんし、する必要すらない小さなツールと考えていますが、以下のリポジトリにすべて含まれています。コアの実装は 150 行にも満たないものです

[https://github.com/ghjcwrk/blogx](https://github.com/ghjcwrk/blogx)

内部パーサーとして hono/css を使用しています。お使いのフレームワークのパーサーに合わせる必要もきっとあるでしょう

ショートハンドは Panda.css から拝借したもので、私のプロダクト都合で膨らませていない部分もあります

- 「この場合はどうすればいいですか？」

- 「こういうケースでは破綻しませんか？」

- 「Tailwind CSS というベストプラクティスを捨てる意図は？ 効果は？」

- 「CSS を型安全にする意味は？」

私自身はある程度答えられるかもしれません。ですが自分たちのプロダクトやチームの内側からではなく、他者に正解を求める人にとっては TSS はきっと不親切な道具です

ただし、自分で選び、自分で設計し、自分で責任を取る。その当たり前の営みに TSS は小さな思想として寄り添います

> TSS は DSL ではないため、TypeScript を書ける開発者であれば、1〜2 時間で使い始められます。Zod 構文に慣れていれば 10 分です
>
> TSS は Tailwind CSS や PostCSS などと排他関係にはなく、既存コードとの共存・移行も段階的に可能です

---
